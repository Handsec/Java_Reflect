package main.java.exploit; // 注意包名

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.io.InputStream;
import java.io.OutputStream;

public class VulnerableService {

    // 看起来无害的公共方法
    public String echo(String message) {
        System.out.println("Executing echo with message: " + message);
        return "Echoing: " + message;
    }

    // 一个私有方法，本不应该被外部直接调用
    private String sensitiveOperation(String data) {
        System.out.println("[PRIVATE] Executing sensitive operation with data: " + data);
        // 模拟执行一个敏感操作，比如读取文件、修改配置等
        return "[PRIVATE] Sensitive data processed for: " + data;
    }

    // ** 危险方法：这个方法会执行传入的系统命令！ **
    public void executeCommand(String command) {
        System.out.println("[DANGER] Attempting to EXECUTE command: " + command); // 突出警告信息

        Process process = null;
        try {
            // --- 真实执行系统命令的代码块 ---
            // 对于Windows系统执行 calc.exe，你传入的 command 参数就是 "calc.exe"
            // 对于Linux/macOS系统，你可以尝试 "xterm" 或其他图形界面程序，或者简单的命令如 "ls /"
            // 注意：简单的 command.split(" ") 对于包含空格或特殊字符的命令不健壮，真实场景需要更复杂的解析或直接使用 exec(String[] cmdarray)
            String[] commandArgs;
            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                // Windows 命令可能需要 cmd /c
                commandArgs = new String[]{"cmd", "/c", command};
            } else {
                // Linux/macOS 可以直接执行大部分简单命令
                commandArgs = command.split(" ");
            }


            ProcessBuilder pb = new ProcessBuilder(commandArgs);
            pb.inheritIO(); // 将子进程的标准输出和标准错误连接到当前Java进程的控制台
            process = pb.start(); // 启动子进程

            int exitCode = process.waitFor(); // 等待命令执行完成
            System.out.println("[DANGER] Command execution finished with exit code: " + exitCode);
            // --- 真实执行系统命令的代码块结束 ---

        } catch (IOException e) {
            System.err.println("[DANGER] Failed to execute command: " + command);
            e.printStackTrace();
        } catch (InterruptedException e) {
            System.err.println("[DANGER] Command execution interrupted: " + command);
            e.printStackTrace();
        } catch (Exception e) { // 捕获其他可能的异常
            System.err.println("[DANGER] An unexpected error occurred during command execution: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // 确保清理资源
            if (process != null) {
                // 为了确保进程被终止，特别是对于长期运行的命令
                try {
                    process.getInputStream().close();
                    process.getOutputStream().close();
                    process.getErrorStream().close();
                } catch (IOException ignore) {
                }
                process.destroy(); // 尝试正常终止进程
                try {
                    process.waitFor(1, java.util.concurrent.TimeUnit.SECONDS); // 给点时间让它退出
                } catch (InterruptedException ignore) {}
                if (process.isAlive()) { // 如果还没死
                    process.destroyForcibly(); // 强制终止
                }
            }
        }
    }

    // ** 存在漏洞的服务方法：根据用户输入动态调用方法 **
    // 这个方法没有对输入的 className, methodName 进行安全校验
    public String processRequestVulnerable(String className, String methodName, String param) {
        System.out.println("\n--- Processing Request ---");
        System.out.println("Class: " + className + ", Method: " + methodName + ", Param: " + param);
        try {
            // 1. 根据字符串获取 Class 对象
            Class<?> clazz = Class.forName(className);
            System.out.println("Found Class: " + clazz.getName());

            // 2. 创建类的实例
            // 假设类有无参构造器，并设置为可访问（对于私有构造器也适用）
            Constructor<?> constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true); // 使私有构造器也可访问
            Object instance = constructor.newInstance();
            System.out.println("Created instance of " + clazz.getName());

            // 3. 根据方法名和参数类型获取 Method 对象
            // ** 危险点：使用 getDeclaredMethod (可以获取私有方法) 并强制设置为可访问 **
            Method method = clazz.getDeclaredMethod(methodName, String.class); // 获取声明的方法 (包括私有的)，假设方法接收一个 String 参数
            method.setAccessible(true); // 强制设置为可访问
            System.out.println("Found Method: " + method.getName());

            // 4. 调用方法
            Object result = method.invoke(instance, param);
            System.out.println("Method invoked.");


            return "Method invoked successfully: " + result;

        } catch (ClassNotFoundException e) {
            System.err.println("Error: Class not found - " + className);
            return "Error: Class not found - " + className;
        } catch (NoSuchMethodException e) {
            System.err.println("Error: Method not found or wrong signature - " + methodName + " or expected param String");
            // e.printStackTrace(); // 打印堆栈信息辅助调试
            return "Error: Method not found or wrong signature - " + methodName;
        } catch (InstantiationException | IllegalAccessException e) {
            System.err.println("Error: Could not instantiate class or access method/constructor.");
            e.printStackTrace();
            return "Error during access or instantiation: " + e.getMessage();
        } catch (InvocationTargetException e) {
            System.err.println("Error: Exception occurred within the invoked method.");
            e.printStackTrace(); // 打印被调用的方法内部的异常堆栈
            return "Error during invocation: Exception in target method - " + e.getTargetException().getMessage();
        } catch (Exception e) { // 捕获其他可能的异常
            System.err.println("An unexpected error occurred during reflection process.");
            e.printStackTrace();
            return "An unexpected error occurred: " + e.getMessage();
        }
    }

    // 可以添加一个 main 方法方便直接运行 VulnerableService 进行测试
    // public static void main(String[] args) {
    //     VulnerableService service = new VulnerableService();
    //     // 尝试调用 processRequestVulnerable 进行测试
    // }
}